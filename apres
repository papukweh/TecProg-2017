#!/usr/bin/python3
import pygame as pg
import fileinput

from math import *

pg.init()                                 # inicialização do sistema
myfont = pg.font.SysFont("monospace", 15)

# altura e largura da arena, em células
H, W = 40,24
#(1,0) e (18,11) = bases
#time1 = (0,0); (0,1); (2,0); (3,1); (3,0);
#time2 = (19, 11); (17,11); (16,11); (19, 10); (17,10)

# largura da célula
l = 25
# altura da célula
L = 2*l/sqrt(3)

# cria a janela
scr = pg.display.set_mode((int(1.5*W*L+0.7*l), int(l*H/2 + 1.5*l)+150))
# só para simplificar, atualização da imagem
atu = pg.display.update


# pinta o fundo da janela
scr.fill((0,200,0))
atu()

def convert(i ,j):
    """
    Converte a coordenada (i,j) para a posição em pixels na janela
    """
    if i%2==0:
        x = (1+j)*L + 2*j*L
        y = l + i*l        
    else:
        x = (2.5+j)*L + 2*j*L
        y = l + i*l
    return x,y

class Robô(pg.sprite.Sprite):
    """
    Representa um Robô, possui uma imagem
    """
    def __init__(s, img):
        """
        Construtor, img é o nome do arquivo com a imagem
        """
        pg.sprite.Sprite.__init__(s)
        s.image = pg.image.load(img)
        s.rect = s.image.get_rect()

    def draw(s, i,j):
        """
        Desenha o robô na célula (i,j)
        """
        x, y = convert(i,j)

        # fronteiras do sprite
        l0,h0,l1,h1 = s.rect

        # corrije a posição de acordo com o tamanho do sprite
        s.rect.topleft = [x-l1/2,y-h1/2]
        # desenha
        scr.blit(s.image, s.rect)

class Cristal(pg.sprite.Sprite):
    def __init__(s, img):
        """
        Construtor, img é o nome do arquivo com a imagem
        """
        pg.sprite.Sprite.__init__(s)
        s.image = pg.image.load(img)
        s.rect = s.image.get_rect()

    def draw(s, i,j):
        """
        Desenha o robô na célula (i,j)
        """
        x, y = convert(i,j)

        # fronteiras do sprite
        l0,h0,l1,h1 = s.rect

        # corrije a posição de acordo com o tamanho do sprite
        s.rect.topleft = [x-l1/2,y-h1/2]
        # desenha
        scr.blit(s.image, s.rect)    

    
class cell:
    """
    Representa uma das células da arena
    """
    def __init__(s,i,j,r,g,b):
        """
        Construtor, i e j formam a coordenada
        """
        # Posição do centro
        s.cx, s.cy = convert(i,j)
        # Cor (pode ser passada para o construtor no futuro)
        s.cor = (r,g,b)

        # Vértices do hexágono
        s.pontos = (
            (s.cx-L/2,   s.cy-l),
            (s.cx+L/2, s.cy-l),
            (s.cx+L,   s.cy),
            (s.cx+L/2, s.cy+l),
            (s.cx-L/2, s.cy+l),
            (s.cx-L, s.cy),
            )

        #s.draw();
        
    def draw(s) :
        """
        Desenha a célula
        """
        pg.draw.polygon(scr, s.cor, s.pontos, 0)
        pg.draw.lines(scr, (0,0,0), True, s.pontos, 3)


# Construção da matriz que representa a arena
arena = []
for i in range(int(H/2)):
    arena.append([])
    for j in range(int(W/2)):
        arena[i].append(cell(i,j, 200, 200, 200))
        arena[i][j].draw()

wpx, hpx = pg.display.get_surface().get_size()
label = myfont.render("Base", 2, (0,0,0))
ui_cor = (100, 100, 100)
ui_pontos = ( (0, 4*hpx/5), (wpx, 4*hpx/5), (wpx, hpx), (0, hpx))
pg.draw.polygon(scr, ui_cor, ui_pontos, 0)
scr.blit(label, (10, 4*hpx/5))
scr.blit(label, (1000, 4*hpx/5))

# lista dos robôs definidos
robs = []

cris = Cristal("cris.png")
vida = pg.image.load("vida.png")
bigcris = pg.image.load("bigcris.png")

# atualiza a janela
atu()

# Leitura dos comandos pela entrada padrão ou de um arquivo
for line in fileinput.input():
   # pg.time.wait(50)
    r = line.split()

    # linha começando com 'fim', termina o programa
    if r[0] == 'fim':
        break

    if r[0] == 'atu':
        atu()
        pg.time.wait(100)
        continue

    # linha começando com 'rob', inclui um robô,
    # o segundo argumento na linha é a imagem   
    if r[0] == 'rob':
        robs.append(Robô(r[1]))
        label = myfont.render("Robô "+str((len(robs)-1)), 2, (0,0,0))
        life = myfont.render("    100", 2, (0,0,0))
        cristais = myfont.render("    0", 2, (0,0,0))
        scr.blit(label, (len(robs)*90, 4*hpx/5))
        scr.blit(robs[len(robs)-1].image, (len(robs)*90, 4*hpx/5 + 25))
        scr.blit(life, (len(robs)*90, 4*hpx/5 + 70))
        scr.blit(vida, (len(robs)*90, 4*hpx/5 + 60))
        scr.blit(cristais, (len(robs)*90, 4*hpx/5 + 110))
        scr.blit(bigcris, (len(robs)*90, 4*hpx/5 + 100))
        continue

    if r[0] == 'morte':
        idn, i, j = list(map(int, r[1:]))
        arena[i][j].draw()
        pg.transform.rotate(robs[idn].image, 90)
        robs[idn].draw(i, j)
        atu()
        continue

    if r[0] == 'terr':
        i, j, r, g, b = list(map(int, r[1:]))
        arena[i][j] = cell(i,j,r,g,b)
        arena[i][j].draw()
        atu()
        continue

    if r[0] == 'cris':
        i, j = list(map(int, r[1:]))
        cris.draw(i, j)
        continue

    if r[0] == 'stop':
        pg.time.wait(9999)
        break

    # linha de movimentação:
    # robô, corrdenadas originais, coordenadas finais
    ri, oi, oj, di, dj = list(map(int, r))

    # redesenha a célula original (apaga o robô)
    if 0 <= oi  < H/2 and 0 <= oj < W/2:
        arena[oi][oj].draw()
        atu()
    # desenha o robô na célula de destino
    if 0 <= di  < H/2 and 0 <= dj < W/2 and ri < len(robs):
        robs[ri].draw(di,dj)
        atu()

    # tempo de espera para atualização, apenas para testes
    #pg.time.wait(100)

pg.quit()

# Local variables:
# mode: python
# End:
